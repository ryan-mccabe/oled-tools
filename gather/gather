#!/bin/bash
#
# Copyright (c) 2020, Oracle and/or its affiliates.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, see <https://www.gnu.org/licenses/>.
#
# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
# or visit www.oracle.com if you need additional information or have any
# questions.

###############################################################################
#
# NAME: gather
#
# AUTHOR: Jeffery Yoder
#
# DESCRIPTION: This is going to be just a simple script to gather the
#              sosreport,OS/ExaWatcher, and core file.  Eventually this script
#              will be replaced by a Python version with more functionality.
#
# HISTORY:
#
# Wed Aug 28 13:33:48 MDT 2019 - Initial version.
#
# Tue Sep  3 11:57:08 PDT 2019 - Version 0.1
#
# Fri Sep 13 16:56:01 MDT 2019 - Version 0.2 - Added --log-size=0 to sosreport
#                                to avoid truncated logs.
#
# Thu Sep 19 14:32:50 MDT 2019 - Version 0.3 - Changed logic around core dump
#                                to list core directories if the customer does
#                                not specify the date.
#
# Sat Feb 22 13:22:04 MST 2020 - Version 0.4 - Cleaned up comments, option
#                                logic, and added if statement to skip
#                                OSW/ExaWatcher if there were no files or
#                                directory.
# Wed Feb 26 11:45:04 MST 2020 - Version 0.5 - More housekeeping as well as
#                                fixes for:
#                                LINUX-4682 - gather command should accept long
#                                             and short options.
#                                LINUX-4683 - gather command should log all of
#                                             the screen output to a log file.
#                                LINUX-4685 - gather command should display
#                                             usage message if no arguments
#                                             are passed.
#                                LINUX-4692 - New Exadata systems automatically
#                                             tar up core directories.
#
############################################################
#
# Variables
#

VERSION="0.5";	        # Version string

ARGS="";                # Place holder for arguments.
CORE_DIR="";            # There may be more than one core, so we'll try and
                        # pick the latest.
CORE_SIZE_K=0;          # How big is CORE_DIR in kb.
CORE_NUM=0;             # How many core directories are there?
DATE="";                # For the customer to pass a date of the incident.
                        # This should be used to select the OS/ExaWatcher data
                        # and the core file if possible.
DIR="";                 # Target directory for files.
EXA_DIR="";	        # Where the ExaWatcher stuff is stored.
FS_FREE_K=0;            # Free space (K) in the target filesystem.
FS_SIZE_K=0;            # Total size (K) in the target filesystem.
FS_USED_K=0;            # Used space (K) in the target filesystem.
KDUMP_DIR="";           # Where kdump is configured to write to.
LOG_FILE="";            # Log all the output.
NEEDED_K=0;             # Kb needed to save data (approx).
OSW_SIZE_K=0;           # How big are the OS/ExaWatcher files.
RUN=0;                  # Should the script run?
SHIFT=0;                # Number of command line options and arguments that
                        # were parsed.
SOS_SIZE_K=1048576;     # This is an approximation based on an average of
                        # sosreports I have collected.  Would be nice if had a
                        # better way to estimate.
TMP="";                 # Temp string used to avoid repeating commands.
V="log";                # Variable for verbose option.
YES="NO";               # Answer yes to any/all prompts.


EXA_DIR="/opt/oracle.ExaWatcher/archive";
LOG_FILE="/tmp/gather.log";

############################################################
#
# Global Variables
#
export XZ_DEFAULTS="-v";        # Set verbose for xz.  I want the user to see
                                # the progress.

############################################################
#
# Subroutines
#
#

error() {
   echo "ERROR: $1";
   echo " INFO: Check log file at ${LOG_FILE}.";
   log  "ERROR: $1";
   exit;
}

warn() {
   echo " WARN: $1";
   log  " WARN: $1";
}

info() {
   echo " INFO: $1";
   log  " INFO: $1";
}

log() {
   echo "$1" >> ${LOG_FILE};
}

usage() {

   echo "
USAGE: $0 -r|-d [-h|-y|-v|-t DIR|-d DATE]

   -r,--run     = Run the command.
   -d,--dryrun  = Dryrun the command.
   -h,--help    = Help (this message).
   -w,--when    = Specify the date of the problem (YYYY_MM_DD).
                  Defaults to today's date.
   -t,--target  = Specify the target directory for the files.
   -y,--yes     = Answer yes when prompted.
   -v,--verbose = Verbose

"
}

############################################################
#
# Main
#

########################################
#
# Start the log file
#
echo > ${LOG_FILE};

########################################
#
# Print the version before anything else.
#
info "$0 Version: ${VERSION}";

########################################
#
# Check for root
#
if [ `id -u` != 0 ]
then
   error "You must be root to run this script.";
fi

########################################
#
# Get options as needed
#

ARGS=`getopt -a -n ${0} -o "rdhyvt:w:" -l "run,help,yes,verbose,target:,when:" -- ${@}`;

if [ ${?} -ne 0 ]
then
   usage;
   exit;
fi

eval set -- "$ARGS"

while true
do
   case "${1}" in
      -r|--run)
         RUN=1;
         shift;;
      -d|--dryrun)
         RUN=0;
         shift;;
      -h|--help)
         usage;
         shift;
         exit;;
      -y|--yes)
         YES="YES";
         shift;;
      -v|--verbose)
         V="info";
         shift;;
      -t|--target)
         DIR=${2};
         shift 2;;
      -w|--when)
         DATE=${2};
         shift 2;;
      --)
         shift;
         break;;
  esac
done

########################################
#
# Make sure there's not extra stuff on the command line.
#
if [ "${#}" != 0 ]
then
   if echo $1 | grep -iqs "help"
   then
      usage;
      exit;
   else
      usage;
      error "Invalid argument ${1}.";
   fi
else
   if [ "${ARGS}" == " --" ]
   then
      usage;
      exit;
   fi
fi

########################################
#
# Validate DATE really quick.  Want to fail right away if it's wrong.
#

if [ "${DATE}" != "" ]
then
   echo ${DATE} | egrep -q "^[0-9]{4}_[0-9]{2}_[0-9]{2}$"
   if [ $? -ne 0 ]
   then
      error "${DATE} doesn't seem to be in the right format (YYYY_MM_DD).";
   fi
fi

########################################
#
# Figure out where to write the files and create the dir as needed.
#

${V} "Finding target directory";

if [ "${DIR}" == "" ]	# Determine the local directory with the most space.
then
   ${V} "Target dir not provided, determining local filesystem with most free space."
   TMP=`df -klP | egrep -v "^File|tmpfs" | awk '{print $2,$4,$6}' | sort -rn | head -1`;
   DIR=`echo ${TMP} | awk '{print $3}'`;
   FS_FREE_K=`echo ${TMP} | awk '{print $2}'`;
   FS_SIZE_K=`echo ${TMP} | awk '{print $1}'`;
   FS_USED_K=$((FS_SIZE_K - FS_FREE_K));
   ${V} "${DIR} has ${FS_FREE_K}kb";
else
   if [ -d "${DIR}" ]	# Make sure the dir that was passed is valid.
   then
      TMP=`df -klP ${DIR} | egrep -v "^File|tmpfs" | awk '{print $2,$4,$6}'`; # Don't want to run df more than we have to.
      FS_FREE_K=`echo ${TMP} | awk '{print $2}'`;
      FS_SIZE_K=`echo ${TMP} | awk '{print $1}'`;
      FS_USED_K=$((FS_SIZE_K - FS_FREE_K));
      ${V} "${DIR} has ${FS_FREE_K}kb";
   else
      error "The provided directory, ${DIR}, does not exist.";
   fi
fi


########################################
#
# Check for core file.
#

${V} "Trying to figure out the core file.";

########################################
#
# Hardcoding this to the values used by Exadata Cloud.
# This needs a module that parses all the combinations of /etc/kdump.conf.
# Exadata dom0 = /crashfiles.
# Exadata domU = /u01/crashfiles.
#

for D in /crashfiles /u01/crashfiles
do
   if [ -d ${D} ]
   then
      KDUMP_DIR="${D}";
      break;	# Stop after the first one.  Not sure if it matters either way.
   fi
done

if [ "${KDUMP_DIR}" == "" ]
then
   warn "The configured kdump directory, ${KDUMP_DIR} does not exist.  Will not add core to gathering.";
else
   ${V} "${KDUMP_DIR} exists.";

   CORE_NUM=`ls -d ${KDUMP_DIR}/* 2> /dev/null | grep -v "*.log$" | wc -l`;

   if [ ${CORE_NUM} -eq 0 ]
   then
      info "There are no core files in ${KDUMP_DIR}.";
   else
      ${V} "There is/are core file/s.";

      #
      # I guess if there is a DATE provided I need to check for the core on
      # that date.
      #
      if [ "${DATE}" != "" ]
      then
         ls -d ${KDUMP_DIR}/*$(echo ${DATE} | sed -e 's/_/-/g')* >/dev/null 2>&1;
         if [ ${?} -eq 0 ]
         then
            CORE_DIR=`ls -d ${KDUMP_DIR}/*$(echo ${DATE} | sed -e 's/_/-/g')*` 2>/dev/null;
            CORE_DIR=`basename ${CORE_DIR}`;
            ${V} "Core directory/file = ${CORE_DIR}";
         else
            warn "There is no core file for the date specified.";
            CORE_DIR="";
         fi
      else

         TMP="";

         info "Date not provided so listing the available core directories:";

         ls -rtd ${KDUMP_DIR}/* | grep -v ".log$" | cat -b;
         printf "\nPlease select a core directory or file (0 for none) : ";
         read TMP;

	 #
	 # Checking for every thing but negative numbers and floating point.
	 #
         if [ "${TMP}" == "" -o "${TMP}" == "0" -o `echo "${TMP}" | grep -ci "[a-z]"` -ne 0 ]
         then
             info "Core collection skipped."
             CORE_DIR="";
         else
            CORE_DIR=$(basename `ls -rtd ${KDUMP_DIR}/* | grep -v ".log$" | head -${TMP} | tail -1`);
            ${V} "Selected ${TMP}, ${CORE_DIR}.";
         fi
      fi

      if [ "${CORE_DIR}" != "" ]
      then
         CORE_SIZE_K=`du -skx ${KDUMP_DIR}/${CORE_DIR} | awk '{print $1}'`;
         ${V} "${CORE_DIR} is ${CORE_SIZE_K} kb.";
      fi

      #
      # Just a guess that we will get at least 50% compression from xz if it's
      # a dir.  Otherwise it's probably a file that is already compressed.
      #
      if [ -d ${KDUMP_DIR}/${CORE_DIR} ]
      then
         NEEDED_K=$((CORE_SIZE_K/2));
         ${V} "Currently needed = ${NEEDED_K}kb.";
      else
         NEEDED_K=$((CORE_SIZE_K));
         ${V} "Currently needed = ${NEEDED_K}kb.";
      fi

   fi
fi

########################################
#
# Need DATE set.
#
if [ "${DATE}" == "" ]
then
   DATE=`date +%Y_%m_%d`;
fi


########################################
#
# OSWatcher/ExaWatcher - I'm just going to do ExaWatcher in this version, and
#                        I'm going to collect an entire day.
#
${V} "Checking for ExaWatcher.";

if [ ! -d ${EXA_DIR} ]
then
   warn "Could not find ExaWatcher directory at ${EXA_DIR}.";
   OSW_SIZE_K=0;
else
   ${V} "Figure out the size of OS/ExaWatcher data in ${EXA_DIR}";

   OSW_SIZE_K=`du -skx ${EXA_DIR}/*/${DATE}* 2> /dev/null | awk 'BEGIN{T=0;} {T+=$1;} END{print T}'`;

   if [ ${OSW_SIZE_K} -eq 0 ]
   then
      warn "No OSW/ExaWatch data found.";
   else
       NEEDED_K=$((NEEDED_K+OSW_SIZE_K));
       ${V} "Currently needed = ${NEEDED_K}kb";
   fi
fi

########################################
#
# Check for space needed. This needs to be smarter in the future.  Set a %used limit.
#

if [ ${FS_FREE_K} -lt ${NEEDED_K} ]
then
   error "There is not enough free space in ${DIR}.  Need ${NEEDED_K}kb.";
fi

if [ ${RUN} -eq 0 ]
then
   info "Exiting due to dryrun.";
   info "Check log file ${LOG_FILE}.";
   exit;
fi

########################################
#
# Start gathering data.
#
${V} "Check for and create subdir as needed.";

if [ ${DIR} == "/" ]
then
   DIR="/gather";
else
   DIR="${DIR}/gather";
fi

if [ -d ${DIR} ]	#Subdir is already there, may be data as well.
then
   if [ `ls ${DIR} | wc -l` -ne 0 ]
   then
      if [ "${YES}" == "NO" ]
      then
         info "${DIR} exists.  I am about to remove everything under ${DIR}:"
         ls -l ${DIR};
         echo -n "

     Are you sure you want to continue? (y/N): ";
         read TMP;
         case ${TMP} in
            y) :;;
            Y) :;;
            *) error "Exiting at user's request.";;
         esac
      fi

      rm ${DIR}/* 2>/dev/null;
   fi

else

   mkdir ${DIR};
   if [ $? -ne 0 ]
   then
      error "Unable to create ${DIR}.";
   fi
fi

########################################
#
# core file
#

if [ "${CORE_DIR}" == "" ]
then
   info "No core directory found.  Skipping core file.";
else
   if [ -d ${KDUMP_DIR}/${CORE_DIR} ]
   then
      info "Tar up and compress core dir (${CORE_DIR}). Please be patient.";
      tar Jcvf ${DIR}/`hostname`_`date +%s`_core.txz ${KDUMP_DIR}/${CORE_DIR} >> ${LOG_FILE};
   else
      info "Copy core file (${CORE_DIR}).  Please be patient."
      cp ${KDUMP_DIR}/${CORE_DIR} ${DIR};
   fi

fi

########################################
#
# ExaWatcher
#

if [ ${OSW_SIZE_K} -ne 0 ]
then
   info "Tar up and compress ExaWatcher data. Please be patient.";
   tar -Jcvf ${DIR}/`hostname`_`date +%s`_ExaWatcher.txz ${EXA_DIR}/*/${DATE}* >> ${LOG_FILE};
fi

########################################
#
# sosreport
#

info "Running sosreport. Please be patient.";
sosreport --tmp-dir="${DIR}" --batch --all-logs --log-size=0 -k sar.all_sar=on >> ${LOG_FILE};


info "

Please upload the files from ${DIR}.
Check ${LOG_FILE} for details.

";

